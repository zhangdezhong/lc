

2、HTTP over SSL/TLS
3、SSL 使用了许多密码学最先进的研究成果，综合了
    对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，
    能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。
1、匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；
2、透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；
3、正向代理：靠近客户端，代表客户端向服务器发送请求；
4、反向代理：靠近服务器端，代表服务器响应客户端的请求；

TCP/IP 是网络世界最常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；
DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射；
URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL；
HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳；代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。

第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，
    使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。
第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。
    因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、
    广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。
第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，
    是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。
第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，
    有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。

MAC 层的传输单位是帧（frame），
IP 层的传输单位是包（packet），
TCP 层的传输单位是段（segment），
HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

OSI
第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；
第二层：数据链路层，它基本相当于 TCP/IP 的链接层；
第三层：网络层，相当于 TCP/IP 里的网际层；
第四层：传输层，相当于 TCP/IP 里的传输层；
第五层：会话层，维护网络中的连接状态，即保持会话和同步；
第六层：表示层，把数据转换为合适、可理解的语法和语义；
第七层：应用层，面向具体的应用传输数据。


第一层：物理层，TCP/IP 里无对应；
第二层：数据链路层，对应 TCP/IP 的链接层；
第三层：网络层，对应 TCP/IP 的网际层；
第四层：传输层，对应 TCP/IP 的传输层；
第五、六、七层：统一对应到 TCP/IP 的应用层。

所谓的“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。
所谓的“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、
                                    主机名、资源类型等数据，再用适当的策略转发给后端服务器。

凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。


例如，你要访问“www.apple.com”，就要进行下面的三次查询：
访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；
访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；
最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。


SYN、SYN/ACK、ACK 的三个包之后


HTTP 协议在规范文档里详细定义了报文的格式，规定了组成部分，解析规则，还有处理策略，
所以可以在 TCP/IP 层之上实现更灵活丰富的功能，例如连接控制，缓存管理、数据编码、内容协商等等。

字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；
字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；
字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；
字段的顺序是没有意义的，可以任意排列不影响语义；字段原则上不能重复，
除非这个字段本身的语义允许，例如 Set-Cookie。

首先要说的是 Host 字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 
    规范里要求必须出现的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。
Date 字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。
Server 字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，
        例如在我们的实验环境里它就是“Server: openresty/1.15.8.1”，即使用的是 OpenResty 1.15.8.1。
实体字段里要说的一个是 Content-Length，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。
    服务器看到这个字段，就知道了后续有多少数据，可以直接接收。
    如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。
比如，你发起了一个 GET 请求，想获取“/orders”这个文件，但这个文件保密级别比较高，不是谁都能看的，服务器就可以有如下的几种响应方式：
    假装这个文件不存在，直接返回一个 404 Not found 报文；
    稍微友好一点，明确告诉你有这个文件，但不允许访问，返回一个 403 Forbidden；
    再宽松一些，返回 405 Method Not Allowed，然后用 Allow 头告诉你可以用 HEAD 方法获取文件的元信息。
GET 方法应该是 HTTP 协议里最知名的请求方法了，也应该是用的最多的，
    自 0.9 版出现并一直被保留至今，是名副其实的“元老”。它的含义是请求从服务器获取资源，
HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，
    但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。
POST/PUT接下来要说的是 POST 和 PUT 方法，这两个方法也很像。
    PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，
    通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义。
DELETE 方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。
    当然，更多的时候服务器就直接不处理 DELETE 请求。
CONNECT 是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，
    这时 Web 服务器在中间充当了代理的角色。
OPTIONS 方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。
    它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。
TRACE 方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。
    它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。

所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。
按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，
    只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。

所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。
    很显然，GET 和 HEAD 既是安全的也是幂等的，
    DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。
    POST 按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；
    PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。

URI，也就是统一资源标识符（Uniform Resource Identifier）。因为它经常出现在浏览器的地址栏里，所以俗称为“网络地址”，简称“网址”。
URI 不完全等同于网址，它包含有 URL 和 URN 两个部分，在 HTTP 世界里用的网址实际上是 URL——统一资源定位符（Uniform Resource Locator）。
    但因为 URL 实在是太普及了，所以常常把这两者简单地视为相等。

URI 最常用的形式，由 scheme、"://"、"user:passwd@"、host:port、path 和 query、#fragment 四个部分组成，但有的部分可以视情况省略。
    URI 的 path 部分必须以“/”开始，也就是必须包含“/”，不要把“/”误认为属于前面 authority。

URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。
    例如，空格被转义成“%20”，“?”被转义成“%3F”。而中文、日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”。
    escape已经被废弃了，我补充一下encodeURI的原理。
    把字符（unicode）编码成utf-8，utf-8是用1-4个字节表示的，
    所以每个字节转换成16进制并在前面用百分号（%）连接，最后并把每个字节转换的结果连接起来

URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；
URI 通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；
scheme 叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问；
“host:port”表示资源所在的主机名和端口号；
path 标记资源所在的位置；
query 表示对资源附加的额外要求；
在 URI 里对“@&/”等特殊字符和汉字必须要做编码，否则服务器收到 HTTP 报文后会无法正确处理。

状态码
    1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
        101 Switching Protocols”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。
            而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了
    2××：成功，报文已经收到并被正确处理；
        “200 OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，
            如果是非 HEAD 请求，通常在响应头后都会有 body 数据。
        “204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。
        “206 Partial Content”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，
            也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。
            状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认
    3××：重定向，资源位置发生变动，需要客户端重新发送请求；
        “301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。
        “302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问
        “304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。
            它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。
    4××：客户端错误，请求报文有误，服务器无法处理；
        “400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。
            所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。
        “403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，
            可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。
        “404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，
            而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。
        “405 Method Not Allowed”不允许使用某些方法操作资源，例如不允许 POST 只能 GET；
        “406 Not Acceptable”资源无法满足客户端请求的条件，例如请求中文但只有英文；
        “408 Request Timeout”请求超时，服务器等待了过长的时间；
        “409 Conflict”多个请求发生了冲突，可以理解为多线程并发时的竞态；
        “413 Request Entity Too Large” 请求报文里的 body 太大；
        “414 Request-URI Too Long”请求行里的 URI 太大；
        “429 Too Many Requests”客户端发送了太多的请求，通常是由于服务器的限连策略；
        “431 Request Header Fields Too Large”请求头某个字段或总体太大；
    5××：服务器错误，服务器在处理请求时内部发生了错误。
        “500 Internal Server Error”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。
            不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。
                虽然不利于调试，但能够防止黑客的窥探或者分析。
        “501 Not Implemented”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，
            不过具体什么时候“开业”就不好说了。
        “502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，
            访问后端服务器时发生了错误，但具体的错误原因也是不知道的。
        “503 Service Unavailable”表示服务器当前很忙，暂时无法响应服务，
            我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。

HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；
HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；
HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。

而“请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“队头阻塞”（Head-of-line blocking），
    当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。

HTTP 最大的优点是简单、灵活和易于扩展；
HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；
HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；
HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；
HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；
HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。

MIME 是一个很大的标准规范，但 HTTP 只“顺手牵羊”取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的“MIME type”。
MIME type
    text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。
    image：即图像文件，有 image/gif、image/jpeg、image/png 等。
    audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。
    application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。
        常见的有 application/json，application/javascript、application/pdf 等，
        另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。
Encoding type
    gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；
    deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；
    br：一种专门为 HTTP 优化的新压缩算法（Brotli）。
Content-Type 服务器会在响应报文里用头字段 告诉实体数据的真实类型：
Accept 字段标记的是客户端可理解的 MIME type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，
    例如下面的这个头：  Accept: text/html,application/xml,image/webp,image/png
Accept-Encoding 字段标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，
    同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段 Content-Encoding 里。
Accept-Charset 字符集在 HTTP 里使用的请求头字段是 Accept-Charset，
    但响应头里却没有对应的 Content-Charset，而是在 Content-Type 字段的数据类型后面用“charset=xxx”来表示，这点需要特别注意。
    
    Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，
        这里的“q”是“quality factor”的意思。权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝
        Accept: text/html,application/xml;q=0.9,*/*;q=0.8
Transfer-Encoding: chunked 来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送 
    和“Content-Length”这两个字段是互斥的
1、每个分块包含两个部分，长度头和数据块；
2、长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；
3、数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；
4、最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”。

Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。
    服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段，
        这样客户端就认为服务器没有实现范围请求功能，只能老老实实地收发整块文件了。

第一，它必须检查范围是否合法，范围越界返回状态码 416
第二，如果范围正确，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。
第三，服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，
多段数据
    “multipart/byteranges”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“boundary=xxx”给出段之间的分隔标记。
TCP 建立连接要有“三次握手”，发送 3 个数据包，需要 1 个 RTT；关闭连接是“四次挥手”，4 个数据包需要 2 个 RTT。

Connection，值是“keep-alive”。

使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。
使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。

队头阻塞
    因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。
        队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。
    “队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解，有什么办法呢？这在 HTTP 里就是“并发连接”（concurrent connections），
        也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。
        域名分片”（domain sharding）技术，还是用数量来解决质量的思路。
一个来回就是1rtt，三次回收准确来说是1.5个rtt，四次挥手是两个来回，所以是2rtt。
重定向
301 俗称“永久重定向”（Moved Permanently），意思是原 URI 已经“永久”性地不存在了，今后的所有请求都必须改用新的 URI。
    浏览器看到 301，就知道原来的 URI“过时”了，就会做适当的优化。
    比如历史记录、更新书签，下次可能就会直接用新的 URI 访问，省去了再次跳转的成本。
    搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI。
302 俗称“临时重定向”（“Moved Temporarily”），意思是原 URI 处于“临时维护”状态，新的 URI 是起“顶包”作用的“临时工”。
    浏览器或者爬虫看到 302，会认为原来的 URI 仍然有效，但暂时不可用，所以只会执行简单的跳转页面，
    不记录新的 URI，也不会有其他的多余动作，下次访问还是用原 URI。
303 See Other：类似 302，但要求重定向后的请求改为 GET 方法，
    访问一个结果页面，避免 POST/PUT 重复操作；
307 Temporary Redirect：类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确；
308 Permanent Redirect：类似 307，不允许重定向后的请求变动，但它是 301“永久重定向”的含义。
重定向问题
第一个问题是“性能损耗”。很明显，重定向的机制决定了一个跳转会有两次请求 - 应答，比正常的访问多了一次。
第二个问题是“循环跳转”。如果重定向的策略设置欠考虑，可能会出现“A=>B=>C=>A”的无限循环，不停地在这个链路里转圈圈，后果可想而知。
    所以 HTTP 协议特别规定，浏览器必须具有检测“循环跳转”的能力，在发现这种情况时应当停止发送请求并给出错误提示。
Cookie
    属性“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，
        浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了。
    另一个属性“SameSite”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，
        而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。
    还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。
    但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。

    Cookie 是服务器委托浏览器存储的一些数据，让服务器有了“记忆能力”；
    响应报文使用 Set-Cookie 字段发送“key=value”形式的 Cookie 值；
    请求报文里用 Cookie 字段发送多个 Cookie 值；
    为了保护 Cookie，还要给它设置有效期、作用域等属性，常用的有 Max-Age、Expires、Domain、HttpOnly 等；
    Cookie 最基本的用途是身份识别，实现有状态的会话事务。

    Cookie 最基本的一个用途就是身份识别，保存用户的登录信息，实现会话事务。
    Cookie 的另一个常见用途是广告跟踪。
服务器的缓存控制
    “Cache-Control”，里面的值“max-age=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”
        时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），
            而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。
    no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；
    no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，
        而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；
    must-revalidate：又是一个和 no-cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。
条件请求
    我们最常用的是“if-Modified-Since”和“If-None-Match”这两个。
        需要第一次的响应报文预先提供“Last-modified”和“ETag”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。
    ETag 是“实体标签”（Entity Tag）的缩写，是资源的一个唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题。
    强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，
        只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。
    “If-Unmodified-Since”“If-Match”和“If-Range”，其实只要你掌握了“if-Modified-Since”和“If-None-Match”，可以轻易地“举一反三”。

“计算机科学领域里的任何问题，都可以通过引入一个中间层来解决”
    （在这句话后面还可以再加上一句“如果一个中间层解决不了问题，那就再加一个中间层”）。TCP/IP 协议栈是这样，而代理也是这样。
代理最基本的一个功能是负载均衡

健康检查：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；
安全防护：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载；
加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本；
数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应；
内容缓存：暂存、复用服务器响应，这
    Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，
        代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。
“X-Forwarded-For”的字面意思是“为谁而转发”，形式上和“Via”差不多，也是每经过一个代理节点就会在字段里追加一个信息。
X-Forwarded-For”和“X-Real-IP”，还出现了两个字段：“X-Forwarded-Host”和“X-Forwarded-Proto”，
    它们的作用与“X-Real-IP”类似，只记录客户端的信息，分别是客户端请求的原始域名和原始协议名。
HTTPS： 由“HTTP over TCP/IP”变成了“HTTP over SSL/TLS”


TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，
    但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES 和 ChaCha20。
对称算法还有一个“分组模式”的概念，它可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文）。
最早有 ECB、CBC、CFB、OFB 等几种分组模式，但都陆续被发现有安全漏洞，所以现在基本都不怎么用了。
    最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，
    常用的是 GCM、CCM 和 Poly1305。

它有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。
    两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。
RSA 可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“整数分解”的数学难题，
    使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。
ECC（Elliptic Curve Cryptography）是非对称加密里的“后起之秀”，它基于“椭圆曲线离散对数”的数学难题，
    使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名。
目前比较常用的两个曲线是 P-256（secp256r1，在 OpenSSL 称为 prime256v1）和 x25519。
    P-256 是 NIST（美国国家标准技术研究所）和 NSA（美国国家安全局）推荐使用的曲线，而 x25519 被认为是最安全、最快速的曲线。
比起 RSA，ECC 在安全强度和性能上都有明显的优势。160 位的 ECC 相当于 1024 位的 RSA，而 224 位的 ECC 则相当于 2048 位的 RSA。
    因为密钥短，所以相应的计算量、消耗的内存和带宽也就少，加密解密的性能就上去了，对于现在的移动互联网非常有吸引力。
虽然非对称加密没有“密钥交换”的问题，但因为它们都是基于复杂的数学难题，运算速度很慢，
    即使是 ECC 也要比 AES 差上好几个数量级。如果仅用非对称加密，虽然保证了安全，但通信速度有如乌龟、蜗牛，实用性就变成了零

非对称加密基于大数运算，比如大素数或者椭圆曲线，是复杂的数学难题，所以消耗计算量，运算速度慢。

为了兼容 1.1、1.2 等“老”协议，TLS1.3 会“伪装”成 TLS1.2，新特性在“扩展”里实现；
1.1、1.2 在实践中发现了很多安全隐患，所以 TLS1.3 大幅度删减了加密算法，
    只保留了 ECDHE、AES、ChaCha20、SHA-2 等极少数算法，强化了安全；
TLS1.3 也简化了握手过程，完全握手只需要一个消息往返，提升了性能。

不过有一种叫“HSTS”（HTTP 严格传输安全，HTTP Strict Transport Security）的技术可以消除这种安全隐患。
    HTTPS 服务器需要在发出的响应头里添加一个“Strict-Transport-Security”的字段，再设定一个有效期，
    例如：Strict-Transport-Security: max-age=15768000; includeSubDomains

帧开头是 3 个字节的长度（但不包括头的 9 个字节），默认上限是 2^14，最大是 2^24，也就是说 HTTP/2 的帧通常不超过 16K，最大是 16M。
    长度后面的一个字节是帧类型，大致可以分成数据帧和控制帧两类，HEADERS 帧和 DATA 帧属于数据帧，
    存放的是 HTTP 报文，而 SETTINGS、PING、PRIORITY 等则是用来管理流的控制帧。